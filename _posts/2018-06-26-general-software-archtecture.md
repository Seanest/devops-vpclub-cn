---
post_title: 软件架构
post_name: general-software-architecture
author: 邓冰寒
post_date: 2018-06-26 10:00:00
layout: post
link: >
  https://devops.vpclub.cn/general-software-architecture/
published: true
tags:
  - Software Architecture
categories:
  - 通用
---

# 软件架构

## 概述

谈到软件架构，实际上是我们在对整个软件系统做重要的规划。这意味着我们的决定会关系到所有的需求（包括性能、安全等），系统组织架构，系统各部分之间如何通讯，如果有外部依赖，如何指引工程师去实现，其中有什么风险需要考虑等等。

没有经过缜密的架构设计的软件，代码往往杂乱无章堆积，当代码越堆越多，维护成本会非常高，特别是传统的单体服务架构，往往为了业务能快速上线而堆积业务代码，团队成员的更迭及技术或业务水平参差不齐亦会带来维护的困难。

很显然，我们需要软件架构，而软件架构包含一系列的选型和决策。如果我们需要对软件架构做更改，需要考虑是否会带来很大的影响，是否难以更改？

## 软件架构的基本要求

* 必须安全可靠，容易维护；
* 要有领域概念，容易理解；
* 应该长期可用，容易扩展；
* 应对需求变更，容易实现；
* 能够水平扩展，要高可用；
* 没有重复代码，容易重构；
* 对于新增功能，性能不变；

除了以上基本要求，软件架构应有以下特点

* 用户体验要好；
* 可伸缩性好，用户容易适应；
* 能支撑业务增长（如海量用户）；
* 高性能，速度快；
* 容易更改和新增功能；
* 容易运行测试。

## 传统单体服务技术架构

* 成功的应用会随着时间变得巨大，最终代码变的很难修改，无法应对快速迭代
* 难以测试和持续集成部署，部署时间长
* 可靠性低，任何局部问题可以导致整个系统崩溃，任何改动都可能造成巨大风险
* 系统启动时间变长，难以使用最新的技术来提升性能

## 微服务介绍和发展历程

![svc-history](/images/general-software-architecture/svc-revolution.png)

* 单体服务架构：服务臃肿，业务错综复杂，相互依赖，紧耦合，高风险
* 面向服务架构：服务拆分，松耦合，服务治理，稳定性提高
* 微服务架构：粒度更细，去中心化，服务自治，灵活部署

## 微服务的优点与挑战

* 优点：
  * 根据不同业务领域拆分成细粒度的服务，解决了复杂性问题
  * 每个微服务有自己的数据库
  * 服务可以由不同功能团队完成，遵循服务自治原则
  * 独立部署，容易持续集成和持续交付
  * 根据业务量来水平伸缩特定服务
* 挑战及应对措施：
  * 服务间通讯变得复杂怎么办？
    * 使用服务发现机制及RPC通讯
  * 客户端要向N个服务发送请求？  
    * 使用API网关，客户端只需要和API网关通讯

## 微服务开发遵循的十二个基本要素

1. 基准代码: 一份基准代码只允许一份部署
2. 依赖: 显式声明依赖关系
3. 配置: 在环境中存储配置，不提交到基准代码库
4. 后端服务: 把后端服务当作附加资源，保持松耦合
5. 构建，发布，运行: 严格分离构建和运行，不要修改运行中的代码
6. 进程: 以一个或多个无状态进程运行应用，数据持久化
7. 基准代码: 一份基准代码只允许一份部署
8. 依赖: 显式声明依赖关系
9. 配置: 在环境中存储配置，不提交到基准代码库
10. 后端服务: 把后端服务当作附加资源，保持松耦合
11. 构建，发布，运行: 严格分离构建和运行，不要修改运行中的代码
12. 进程: 以一个或多个无状态进程运行应用，数据持久化

## 服务发现

* 为什么要服务发现？
  * 微服务部署在容器上，IP是动态分配的
  * 扩展、失败、升级导致ip变化
  * 为了实现自动化部署
* 常用的服务发现机制
  * Netflix Eureka
  * Zookeeper
  * Kubernetes DNS Service Discovery

## 服务间通讯

* 由于系统被拆分成许多的微服务，服务间通信协议一般有下面几种：
  * REST
  * Thrift
  * GRPC

## 传统服务事务管理

* 单体应用通常使用ACID事务
  * 原子化
  * 一致性
  * 隔离
  * 持久
* 事务在微服务架构下的挑战
  * 保持服务一致性
  * 跨服务数据查询

## 分布式微服务事务管理

* 各个服务自动更新数据库和发布事件
* 消息代理确保事件传递成功
* 提供弱一致性，最终一致性
* 案例：
  * 订单服务创建订单，并发布“订单创建”事件
  * 库存服务获取“订单创建”事件，预扣相应库存，并发布“库存预扣”事件
  * 订单服务获取“库存预扣”事件并处理订单支付，如订单处理成功，发布“订单支付”事件
  * 库存服务获取“订单支付”事件，扣除库存，并发布“库存扣除”事件。
